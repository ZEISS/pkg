# Pkg

[![Test & Lint](https://github.com/ZEISS/pkg/actions/workflows/main.yml/badge.svg)](https://github.com/ZEISS/pkg/actions/workflows/main.yml)
[![Go Reference](https://pkg.go.dev/badge/github.com/zeiss/pkg.svg)](https://pkg.go.dev/github.com/zeiss/pkg)
[![Go Report Card](https://goreportcard.com/badge/github.com/zeiss/pkg)](https://goreportcard.com/report/github.com/zeiss/pkg)
[![Taylor Swift](https://img.shields.io/badge/secured%20by-taylor%20swift-brightgreen.svg)](https://twitter.com/SwiftOnSecurity)
[![Volkswagen](https://auchenberg.github.io/volkswagen/volkswargen_ci.svg?v=1)](https://github.com/auchenberg/volkswagen)
[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)

`pkg` is a collection of Go packages that make the life of a Go developers at ZEISS easier.

## Installation

```bash
go get github.com/zeiss/pkg
```

Go has a pretty good standard library, but there are some things that are missing. This collection of small packages is meant to fill those gaps.

## Casting values

There is the typical case of pointers you need to deference. For example in the strict interfaces generated by [oapi-codegen](https://github.com/oapi-codegen/oapi-codegen).

```go

Somestruct {
  Field: cast.Ptr(req.Field),
}

```

Or the other way around, you have a pointer and you want to get the value or a default value.

```go

SomeStruct {
  Field: cast.Value(req.Field),
}

```

Return a default value of a `nil` pointer.

```go
type Foo struct {}
cast.Zero(Foo) // &Foo{}
```

## Converting values

There is also always the case to covert a value to a specific other value.

```go
// String converts a value to a string.
b := true
s := cast.String(b)

fmt.Println(s) // "true"
```

There are functions to convert `int`, `string` and `bool` values.

## Databases

There are also more complex tools like the `Database` interface which enables to easliy implement database wrappers.

```go
// Database provides methods for transactional operations.
type Database[R, W any] interface {
	// ReadTx starts a read only transaction.
	ReadTx(context.Context, func(context.Context, R) error) error
	// ReadWriteTx starts a read write transaction.
	ReadWriteTx(context.Context, func(context.Context, W) error) error

	Migrator
	io.Closer
}
```

Or a simple interface to implement servers. This takes for all `signal` and `context` handling.

```go

s, _ := server.WithContext(ctx)
s.Listen(&srv{}, true)

serverErr := &server.ServerError{}
if err := s.Wait(); errors.As(err, &serverErr) {
  log.Print(err)
	os.Exit(1)
}
```

## License

[MIT](/LICENSE)
